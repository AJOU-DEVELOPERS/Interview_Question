> # 객체지향

### 객체 지향 프로그래밍이란?

데이터를 추상화하여 상태와 행위를 가진 객체를 만들고 , 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

대표적인 객체 지향 프로그램에는 C++,C#,JAVA가 있다.

---

### 객체 지향 프로그래밍 탄생 배경

![](https://images.velog.io/images/jinpro/post/cea29190-f949-47d0-aa19-b01ce63bc9e9/image.png)

객체 지향 프로그래밍이 유행하기 전에는 절차 지향 프로그래밍이 유행하고 있었다.  
대표적으로 C 언어가 존재했으며 순차적인 처리가 중요시 되며 컴퓨터의 처리 방식과 유사한 특징이 있다.

컴퓨터가 처리하는 방식과 유사하기 때문에 절차 지향 방식은 실행 속도가 빠르다는 점이 장점이었다.

하지만 절차 지향의 커다란 단점 떄문에 객체 지향 프로그래밍이 유행하게 되었다.

#### 단점 1. 유지 보수

절차 지향 프로그래밍에서는 코드가 엄청 복잡하며 코드의 중복이 심하기 때문에 유지 보수가 엄청 어렵다.

#### 단점 2. 코드 분석

복잡한 알고리즘의 경우, 절차 지향적일 떄 코드를 분석하기 매우 어려워 진다.  
코드를 읽다가 흐름을 놓치게 된다면 코드를 이해하는건 거의 불가능에 가깝다.

#### 단점 3. 순서

절차 지향 프로그래밍에서 순서는 매우 중요하다.  
만약 A->B->C 의 순서로 프로그래밍을 작성해야하지만
A->C->B 의 순서로 코드를 잘못 작성한다면 결과를 얻어내기 어려운 단점이 있다.

따라서 위와 같은 절차 지향 프로그래밍의 단점 떄문에 객체 지향 프로그래밍이 유행하기 시작했다.

### 객체 지향 프로그래밍 장점

이렇게 유행을 차지한 객체 지향 프로그래밍은 다음과 같은 장점을 가지고 있다.

#### 1. 재 사용성

상속 , 추상화, 다형성 등의 특징을 통해 객체를 재사용할 수 있다.  
따라서 시간을 절약하고 생산성을 높일 수 있으며 코드가 간결해 진다.

#### 2. 데이터 은닉

캡슐화를 통한 데이터를 은닉할 수 있다.  
따라서 다른 코드에 의해 침범되지 않는 안전한 프로그램을 구축 가능하다.

#### 3. 대규모 프로그램

프로그램을 객체 단위로 분리함으로써 작업을 분할하고 대규모 프로젝트로 쉽게 업그레이드 가능하다.

---

### 객체지향 프로그래밍 단점

- 컴퓨터의 처리 방식과 다르기 떄문에 절차 지향 프로그래밍 방법보다 실행시간이 비교적 오래 걸린다.
- 객체를 재사용하기 위해 많은 고민과 시간을 설계하는데에 들여야 한다.

이런 단점이 존재하더라도, 객체 지향 프로그래밍이 가져다 주는 이점이 확실하기 떄문에 객체 지향 프로그래밍이 많은 곳에서 활용되고 있다.

---

### 객체지향 키워드

#### 클래스

객체 지향에서 클래스는 특정 객체를 생성하기 위해 변수 또는 메소드를 정의하는 일종의 틀이다.  
즉 , 메타 정보라고 볼 수 있다.

클래스는 특정 클래스의 일부 또는 전체 특성을 상속 받을 수 있으며 자신 또한 다른 클래스에 상속 가능하다.

#### 객체

상태(프로퍼티)와 행동(메서드)을 가진 어떤 대상이다.

인스턴스를 포함하는 포괄적인 개념이다.

#### 인스턴스

클래스에서 정의한 것을 토대로 생성되어 실제 메모링 할당된 데이터라고 볼 수 있다.

즉, 소프트웨어에 실체화가 된 객체이다.

#### 추상화

추상화는 특성을 일반화 하고 특징의 세부사항을 제거하여 단순화 하는것을 의미한다.  
이를 객체에 적용하면 하나의 새로운 타입, 즉 새로운 클래스를 만들어 내는것이 가능하다.

즉 추상화를 통해 클래스라는 틀을 만드는 것이 가능하다.

예를 들어 자동차, 기차, 비행기 객체가 있다고 하자.  
다음과 같은 과정으로 이 객체들을 "틸 것"이라는 클래스로 추상화 할 수 있다.

먼저 공통점을 찾아 일반화 한다면,

1. 사람이 탈 수 있다.
2. 사람을 운반한다.
   라는 특성을 찾을 수 있고,

특징을 찾는다면

1. 기름을 가지고 있다.  
   라는 특징을 찾을 수 있다.

이런 과정을 통해 객체들의 공통되는 특성을 찾아 메서드, 프로퍼티를 찾아낼 수 있고 클래스로 추상화 할 수 있는 것이다

#### 캡슐화

캡슐화란 정보의 은닉을 위해 정보를 캡슐처럼 감싸 숨기는 것을 의미한다.

프로그래밍에서 캡슐화는 외부에 공개하는 인터페이스 이외의 객체 내부 상태, 구현내용 등의 정보는 객체 내부로 숨기는 것을 의미한다.

보통 객체 지향 프로그램에서는 private 이라는 키워드를 통해 이를 구현할 수 있다.

#### 상속

자식 클래스가 부모 클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하는 속성이다.  
만약 부모클래스의 요소를 재정의할 필요가 있다면 오바라이딩을 통해 재사용성을 더욱 높일 수 있다.

객체 지향 프로그래밍에서 코드의 재사용성을 높여주는 아주 중요한 속성중 하나이다.

#### 다형성

상속 받은 기능을 변경하거나 확장하는 것을 의미한다.  
다형성을 통해 코드의 재사용, 유지보수가 용이해진다.

오버라이딩과 오버로딩을 통해 구현가능하다.

#### 오버라이딩

부모클래스의 메서드와 같은 이름, 같은 매개변수로 메서드를 다시 재정의 하는것을 의미한다.  
부모 클래스의 기능을 그대로 사용하며 동시에 기능도 추가할 수 있어 재사용성이 증가한다.

#### 오버로딩

하나의 클래스에서 같은 이름의 함수를 여러개 정의하고 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출 할 수 있게 하는 것이다.  
유사한 역할을 하지만 인자가 다른 메서드들을 정의할 떄 유용하다.
다만, 자바스크립트에서는 문법적인 오류 떄문에 오버로딩이 불가능하지만 arguments 를 이용해 흉내낼 수 있다.

---

### Class Prototype 공통점과 차이점

#### 공통점

- new 키워드를 통해 객체 인스턴스를 생성 가능하다

#### 차이점

- javascript class의 경우 꼭 constructor 가 정의되어야 한다.
- javascript class는 호이스팅이 일어나지 않기 떄문에 꼭 먼저 class를 선언하고 사용해야한다.
- javascript class는 strict 모드로 작동한다 (자바스크립트 느슨한 에러 체크를 해제)
- class는 상속이 가능하나 Prototype은 상속이 불가능 하다.
  - Prototype은 Prototype Chain을 형성하여 상속한다.
- prototype 체인을 활용해 생성된 객체들은 하나의 부모 prototype 객체를 참조하여 프로토타입 체이닝을 통해 메서드, 프로퍼티들을
  참조하기 떄문에 메모리 절약이 가능하다
- 반면에 class를 통해 생성된 객체들은 자신이 메서드,프로퍼티에 대한 정보를 모두 가지고 있기 떄문에 프로토타입 체이닝을 통해 생성된 객체보다 메모리 낭비가 있다.

---

### this와 super 키워드

#### 공통점

- 두 키워드 모두 클래스의 객체를 참조하는 키워드 이다.

#### 차이점

- this는 현재 클래스의 인스턴스를 의미한다.
- super는 현재 클래스가 상속한 부모 클래스의 인스턴스를 의미한다.

super 메서드는 부모 클래스의 함수를 호출할 때 사용하며 부모 클래스의 constructor를 호출할 수 있다.
단, super() 메서드를 사용한다면 this 키워드가 실행되기 전 사용해야한다.

super 키워드를 통해 부모 클래스에 대해 참조를 할 수 있으며 super 키워드를 사용하기 전 super() 메서드를 호출해야한다.
왜냐하면 부모 클래스의 인스턴스가 필요하기 떄문이다.

---

### 객체 인스턴스 비교하는 다양한 방법

1. 빠르지만 제한적인 방법
   이 방법은 빠르게 객체 인스턴스를 비교가능한 방법이지만 객체 내부의 순서도 같아야 하기 떄문에 제한적이다.  
   만약 객체 내부 순서가 다르다면 올바른 결과를 반환하지 않는다

```javascript
const one = {
  fruit: "🥝",
  energy: "255kJ",
};

const two = {
  energy: "255kJ",
  fruit: "🥝",
};
JSON.stringify(one) === JSON.stringify(two); // false
```

2. 느리지만 일반적인 방법
   앞선 방법과 다르게 객체 내부의 순서에 따라 영향은 받지 않지만 느리다.

```javascript
const one = {
  fruit: "🥝",
  energy: "255kJ",
};

const two = {
  energy: "255kJ",
  fruit: "🥝",
};

Object.entries(one).forEach(([key, value], index) => {
  if (!two[key]) console.log(false);
  console.log(two[key] === value);
});
```

---

## SOLID 원칙

[잘 정리된 블로그](https://www.nextree.co.kr/p6960/)

### SOLID 원칙에서 SRP 단일책임원칙에 대해 학습

- 작성된 클래스는 하나의 기능을 가져 해당 클래스에 역할을 부여한다.

---

### SOLID 원칙에서 LSP 리스코프교환원칙 대해 학습

- 자식 클래스와 부모 클래스는 일관되어야 한다.
  - 부모 클래스의 기능을 자식 클래스에서 행할 수 있어야 한다. ( 오버라이딩 하지않기 )
