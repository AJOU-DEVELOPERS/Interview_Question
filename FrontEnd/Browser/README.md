> # 브라우저 동작원리

### 브라우저의 주요 기능

사용자가 선택한 자원(HTML)을 서버에 요청하고 브라우저에 표시하는 것

---

### 브라우저 구성 요소

1. 사용자 인터페이스 - 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분
2. 브라우저 엔진 - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어
3. 렌더링 엔진 - 요청한 콘텐츠를 표시 (HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시)
4. 통신 - HTTP 요청과 같은 네트워크 호출에 사용됨.
5. UI 백엔드 - 콤보 박스, 창 같은 기본적인 장치를 그리며 OS UI를 사용함.
6. 자바스크립트 해석기 - 자바스크립트 코드를 해석하고 실행
7. 자료 저장소 - 자료를 저장하는 계층, 모든 종류의 자원을 하드 디스크에 저장한다.

---

## 렌더링 엔진 vs 브라우저 엔진

[참고 사이트](https://zicodeng.medium.com/explore-the-magic-behind-google-chrome-c3563dbd2739) 2. 브라우저 엔진 - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어 3. 렌더링 엔진 - 요청한 콘텐츠를 표시 (HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시)
라고 앞서 설명했다.

하지만 의미가 모호하여 궁금증이 발생해 자세히 알아보기로 했다.

[그림]
위 그림은 크롬의 아키텍처이다.  
크롬은 멀티 프로세스 아키텍처를 사용한다.  
이 그림에서 가장 중요한 2개의 프로세스는 브라우저 프로세스와 렌더 프로세스이다.  
브라우저 프로세스는 브라우저 엔진이라고 생각하면 된다.  
하지만 렌더링 엔진은 렌더 프로세스 안의 구성품에 불과하다.

브라우저 프로세스는 브라우저에서 모든 렌더 프로세스들과 UI를 그리는데에 책임을 가지는 프로세스이다.

### 브라우저 프로세스

브라우저 프로세스는 main/UI 스레드, I/O 스레드를 가지고 있다.  
main/UI 스레드는 웹 페이지를 렌더링 하는데에 책임이 있는 스레드이며 I/O 스레드는 브라우저 프로세스와 렌더 프로세스들간의 IPC 통신을 책임지는 스레드다.

브라우저 프로세스 = main/UI 스레드 + I/O 스레드이다.

#### Main/UI 스레드에는 4개의 객체가 존재한다.

1. RenderProcessHost 객체
   renderViewHost 에게 renderProcess에게서 받는 view-specific message 를 전달하고 non-view-mseesage 를 처리하는 역할을 한다.
   renderProcess와는 1:1 관계이다

2. RenderViewHost 객체
   이 객체는 RenderProcessHost 에게 view-specific message를 전달 받는다  
   RenderProcessHost 와의 관계는 1:n 인데, renderProcess가 생산하는 renderView 객체가 여러개일 수 있기 떄문이다 (웹 페이지 + 팝업)  
   이 객체는 input events를 받거나 (받는다면 렌더러 프로세스에게 전달함) webpage를 그리는 역할을 한다.

3. webContents 객체
   이 객체는 웹페이지의 1개 탭을 표현해 준다.  
   webpage를 직사각형 모양으로 display 하는 역할을 한다.

4. Browser 객체
   browser window를 표현하고 여러개의 webContent 객체를 가진다.

#### I/O thread

1. Channel 객체
   pipe 로 대화하기 위한 메서드가 정의되어 있으며 render process들과의 IPC 통신을 담당한다
2. ResourceDispatcherHost 객체
   network request를 보내는 역할을 담당한다.  
   만약 render process가 네트워크 request를 보내길 원할 때 RenderProcessHost에게 먼저 보낸 후 RenderProcessHost가 ResourceDispatcherHost 에게 이 요청을 전달한 후 이 객체가 네트워크 상으로 요청을 보낸다.

### Render Process

Main Thread와 render Thread로 구성되어 있으며 렌더링 엔진은 Render Process의 한 요소이다.  
웹 페이지를 구성하는 역할을 담당한다.  
즉 크롬 브라우저에서 탭 안에서 일어나는 거의 모든 일을 담당한다 ()

#### Main Thread

1. RenderProcess
   쓰레드 간 통신 (브라우저 프로세스의 I/O thread <-> 렌더 프로세스 Main Thread && 렌더 프로세스 Main Thread <-> 렌더 프로세스 Render Thread ) 를 담당한다.

#### Render Thread

1. ResourceDispatcher
   웹 페이지가 서버한테 fetch 요청을 보낼때가 있다.  
   render process는 인터넷에 접근할 방법이 없다.  
   그래서 이 객체가 이를 IPC를 통해 가능하도록 한다. (요청을 RenderProcess 객체를 통해 브라우저 프로세스에게 전달함)

2. Webkit
   크롬에서 사용되는 렌더링 엔진이다.
   DOM 트리를 형성하고 웹 페이지의 레이아웃을 잡는 역할을 한다.  
   2개의 주요한 객체를 가진다.
   WebCore 객체는 핵심 레이아웃 함수를 가지고 있으며 JavaScriptCore는 V8 엔진이다.

---

### 크롬 브라우저 요청 과정

1. 브라우저 프로세스 - Main 스레드가 주소창에 입력된 값이 url 인지 검색어 인지 확인 -> 요청할 곳 (검색 엔진 or 페이지 이동) 결정

2. I/O 스레드를 통해 요청을 보냄
3. I/O 스레드가 응답이 들어오면 content-type을 확인하여 html 인지 다운로드 받을 파일인지 확인 -> zip 이라면 다운로드 매니저에게 전달
4. 만약 html일 경우 메인 스레드를 통해 담당 렌더 프로세스를 알아냄 -> IPC를 통해 HTML 데이터 전달
5. 렌더링 엔진의 작동

### 렌더링 엔진 동작 과정

![](https://images.velog.io/images/jinpro/post/d232cbbc-1c5a-4cc4-800f-1772feee7fed/helloworld-59361-2.png)

통신으로부터 요청한 문서의 내용을 얻는 것으로 시작한다.
문서 내용은 보통 8KB 단위로 전송된다.

렌더링 엔진은 HTML문서를 파싱하고 "콘텐츠 트리" 내부에서 태그를 DOM 노드로 변환한다.

렌더 프로세스의 메인 스레드가 사전 로드 스캐너를 실행시켜 img 혹은 link 태그가 있는 경우 HTML 파서에 의해 생성된 토큰들로 네트워크 요청을 보낸다.

외부 CSS 파일같은 스타일 요소도 파싱한다.

스타일 정보와 HTML 표시 규칙은 "렌더 트리"라고 부르는 트리를 생성한다.

렌더 트리 생성이 끝나면 UI백엔드에서 렌더 트리의 각 노드들의 형상을 화면의 정확한 위치에 만들어 낸다.

**일련의 과정들이 점진적**으로 진행된다.

즉, 네트워크로부터 나머지 내용을 전송받을때까지 기다리지 않고, 받은 내용의 일부를 먼저 화면에 표시한다.

![](https://images.velog.io/images/jinpro/post/c02b75fa-8d02-4c0f-b3ee-3936fbbcacf5/helloworld-59361-3.png)

즉,

1. HTML 마크업을 처리하고 DOM 트리를 빌드한다. ("무엇을" 그릴지 결정한다.)
2. CSS 마크업을 처리하고 CSSOM 트리를 빌드한다. ("어떻게" 그릴지 결정한다.)
3. DOM 및 CSSOM 을 결합하여 렌더링 트리를 형성한다. ("화면에 그려질 것만" 결정)
4. 렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산한다. ("Box-Model" 을 생성한다.)
5. 개별 노드를 화면에 페인트한다.(or 래스터화)

---

### 파싱

> 파싱이란, 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것
> 토큰이란, 유효하게 구성된 단위의 집합체 ( === 사전 )

- 어휘 분석 => 토큰화

  - 의미 없는 문자(공백과 줄바꿈) 제거
  - 자료를 토큰으로 분해하는 과정

- 구문 분석 => 트리 구축
  - 언어의 구문 규칙을 적용하여 파싱 트리 생성

1. 어휘 분석기로 자료를 토큰화한다.
2. 토큰이 구뮨 규칙과 일치하는지 확인
3. 일치하면, 파싱 트리에 추가
4. 일치하지 않으면, 파서는 토큰을 내부적으로 저장

위 과정은 반복된다.

위 파싱 과정으로 HTML 파싱을 할 수 없다.

- HTML 언어의 너그러운 속성
- HTML 오류에 대한 브라우저의 관용
- 소스는 파싱하는 동안 변하지 않지만 HTML에서 document.write를 포함하고 있는 스크립트 태그는 토큰을 추가할 수 있기 때문에 파싱이 수정된다.

---

### HTML 파싱

![](https://images.velog.io/images/jinpro/post/61b9fa4e-6a2d-4641-b8fb-72851515091a/image.png)

HTML에서 토큰 종류

- 시작 태그
- 종료 태그
- 속성 이름
- 속성 값

HTML 파싱과정에서 HTML 토큰 종류에 따른 상태를 가지고 있고, 상태에 따라 같은 문자를 읽어도 다른 결과물을 갖는다.

예를들어, 문자 d를 읽었을때 속성 값의 d 인지 div 태그의 d인지 상태에 따라 다르다.

HTML에서 CSS, js, 이미지에 대한 링크 정보를 추출한다. 추출한 정보의 URL을 이용 새로운 요청을 보낸다.

---

### 스크립트와 스타일 시트의 진행 순서

#### 스크립트

웹은 파싱과 실행이 동시에 수행되는 동기화 모델이다.
파서가 `<script>` 태그를 만나면 즉시 파싱하고 실행하기를 기대한다.
스크립트가 실행되는 동안 문서의 파싱은 중단된다.

스크립트가 외부에 있는 경우 우선 네트워크로부터 자원을 가져와야 하는데 이 또한 실시간으로 처리되고 자원을 받을 때까지 파싱은 중단된다.

왜냐하면 `document.write() ` 같은 방법으로 DOM 구성을 바꿀 수 있기 떄문이다.

스크립트를 defer(지연)혹은 async 로 표시할 수 있는데, 표시하면 문서 파싱은 중단되지 않고 문서 파싱이 완료된 이후에 스크립트가 실행된다.
link 태그의 경우에는 `<link rel="preload"`를 통해 빠르게 리소스를 다운로드 할 수 있게 해준다.

#### 스타일 시트

이론적으로 스타일 시트는 **DOM 트리를 변경하지 않기 때문에** 문서 파싱을 기다리거나 중단할 이유가 없다. (하지만 DOM 트리를 이용해 생성함)

그러나 스크립트 문서를 파싱하는 동안 스타일 정보를 요청하는 경우라면 문제가 된다.

스타일이 파싱되지 않은 상태라면 스크립트는 잘못된 결과를 내놓기 때문에 많은 문제를 야기한다.

따라서 DOM 트리 생성과 스타일 시트 형성은 동시에 이루어지진다.  
하지만 스크립트 파일의 실행은 스타일 시트를 먼저 파싱한 이후에 이루어 지게 된다.

이 스타일 시트가 CSSOM 이다.
CSSOM = DOM + CSS

---

### 렌더 트리 구축

DOM 트리가 구축되는 동안 브라우저는 렌더트리를 구축한다.

이 렌터 트리의 루트가 렌더 프로세스의 Render View 객체이다.

이떄 , 렌더링 엔진은 UX 를 위해 HTML 파싱이 완료 되기전 배치와 그리기 과정을 시작하여 내용의 일부를 화면에 표시해 준다.

DOM 트리와 렌더 트리는 1:1 대응 관계가 아니다.
예를들어, head 요소, display : none 값이 할당된 렌더 트리에 나타나지 않는다.

또한, float 처리된 요소나 position값이 적용된 요소는 트리의 다른곳에 배치된 상태로 그려진다.

렌더 트리의 구축은 DOM 노드의 attatch 메서드에 의해 이루어진다.

---

### 레이아웃 (리플로우) 단계

이제 렌더 트리가 생성 되었다.  
렌더 트리가 생성되었으므로 화면에 표시할 노드와 해당 노드의 스타일을 알게 되었다.

하지만 뷰포트 내에서 정확한 위치와 크기는 계산하지 않았으며 이것은 레이아웃 혹은 리플로우라고 불리는 이번 단계에서 진행된다.

이 과정에서는 각 node의 정확한 위치를 파악하기위해 렌더 트리 최상단 부터 트래버스 하여 계산해 낸다.

이 과정을 끝마치면 각 노드의 스타일과 기하학적 형태에 대해 파악이 완료 된다.

이 LayOut 이벤트가 완료되면 Paint이벤트를 발생시킨다.

---

### 페인트

페인트 과정에서는 앞서 말햇듯 렌더링 트리를 화면의 픽셀로 변환한다.

페인트 과정에서는 노드들을 어떤 순서로 화면에 그릴지 결정해야한다.  
예를 들어 z-index 속성이 존재할 때 이를 고려하지 않고 html 노드 순서대로 그림을 그린다면 z-index 속성이 적용되지 않는다.  
이런 경우를 위해 그리는 순서를 계산해야한다.

메인 스레드가 렌더 트리를 순회하며 이를 계산하게 된다.

### 컴포지팅

이제 정말 그릴 차례다.
우린 이제 그릴 순서, 기하학 구조, 노드 스타일 정보를 가지고 있다.
이 정보를 토대로 스크린의 픽셀로 바꾸는 것을 레스터 라이징 or 컴포지팅 이라고 한다.

레스터 라이징과 컴포지팅은 아래 문서에서 확인
[참고 문서](https://developers.google.com/web/updates/2018/09/inside-browser-part3#%EB%A0%8C%EB%8D%94%EB%9F%AC_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98_%EB%82%B4%EB%B6%80_%EB%8F%99%EC%9E%91)

이 과정이 완료되면 컴포지터 프레임이 생성된다 !
컴포지터 프레임이 브라우저 프로세스 메인 스레드에 전달되고 GPU 에게 보내져 화면에 보여지게 된다 ...

### 특정 페이지를 표시할 때까지 서버에 요청하고 받는 전체 과정

1. URL 입력 엔터
2. 웹 브라우저가 URL 해석
3. URL이 문법에 맞으면 url의 host 부분에 encoding을 적용한다.
4. HSTS 목록을 로드해서 확인한다.

- 목록에 존재하면 HTTPS
- 존재하지 않으면 HTTP

5. DNS 조회한다.

- Browser에 해당 Domain이 cache 되어있는지 확인한다.
- 없으면 local에 저장된 hosts 파일에서 참조할 수 있는 Domain이 있는지 확인한다.
- 위 두 가지 방법이 실패하면 DNS로 요청을 보낸다.

6. ARP로 대상의 IP와 MAC address를 알아낸다.

- ARP broadcast를 보내기 위해

7. 대상과 TCP 통신을 통해 Socket을 연다.
8. HTTPS인 경우 TLS handshake가 추가된다.
9. HTTP 프로토콜 요청
10. HTTP 서버 응답
11. HTML,CSS,JS 파싱하여 렌더 트리 구축
12. 그리기

---

### 페이지 로딩 속도 줄이는 방법

- 성능 최적화 된 호스팅 사용
- 이미지 압축하고 최적화
- 리다이렉션 줄이기
- 웹 페이지 캐시
- 브라우저 캐시
- CSS 및 JS 파일에 비동기 및 지연로드를 사용
- CSS, JS , HTML 파일 축소
- CDN 사용
- 불필요한 플러그인 제거

---

### 페이지 로딩에 가장 영향을 주는 요소들을 일반화해보고 정리

- DOM에 접근
  <내용추가>

---

### 로컬에 캐싱되는 경우는 개발자 도구에서 어떻게 표시되는 지 확인

![](https://images.velog.io/images/jinpro/post/59ef2d63-a49b-43fd-b245-d5bd7492849d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-29%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.45.00.png)
<이거맞나>

---

### 최적화

핵심 : Reflow 는 화면에 변화가 있을 때 발생한다.  
화면의 구조가 변경되면 Reflow 과정을 거쳐 화면 구조를 다시 계산한 후 Repaint 과정을 다시 거친다.

화면의 구조가 변경되지 않는 경우 Repaint 과정만 발생한다

#### Repaint만 발생하는 경우

- opacity
- background-color
- visibility
- outline ...

#### Reflow 가 발생하는 경우

- DOM 노드의 추가, 제거
- DOM 노드의 위치 변경
- DOM 노드의 크기 변경(margin, padding, border, width, height 등..)
- CSS3 애니메이션과 트랜지션
- 폰트 변경, 텍스트 내용 변경
- 이미지 크기 변경
- offset, scrollTop, scrollLeft과 같은 계산된 스타일 정보 요청
- 페이지 초기 렌더링
- 윈도우 리사이징

#### 먼저

1. Reflow 를 발생시키는 Css 속성 피하기

- left,top,margin,padding,border,width,height...
- transform 속성은 repaint 만 발생시킨다
- visibilty: invisible는 레이아웃 공간을 차지하지만 display: none은 레이아웃 공간을 차지하지 않아 rendering tree 형성에 제외되기 때문에 성능을 위해 후자를 쓰는 것이 좋다.

2. Dom 깊이를 최소화

- dom tree의 깊이를 최소화 하여 파싱 시간을 줄이자
- position: absolute 또는 position: fixed 를 사용하여 영향 받는 엘리먼트 제한하기

3. 프레임 줄이기 / 애니메이션 css

- 한 프레임 처리가 16ms(60fps) 내로 완료되어야 렌더링 시 끊기는 현상 없이 자연스러운 렌더링을 만들어낼 수 있고, 애니메이션은 JavaScript보다 CSS을 사용하는 것이 좋다.

#### 하지만 어쩔 수 없이 reflow를 발생해야할 때가 있다.

#### 이럴땐 reflow를 최적화 하도록 하자

4. 스타일을 변경할 경우 가장 하위 노드를 변경한다.

- 노드의 스타일을 변경하면 일부 상위 노드와 하위노드까지 영향을 줄 수 있다.
- 따라서 다른 노드에게의 reflow 영향을 최소화 하기위해 가장 하위 노드의 스타일을 변경하도록 하자.

5. 인라인 스타일을 사용하지 않는다.

- 인라인 스타일은 html 파싱 시 레이아웃에 영향을 미쳐 리플로우를 추가적으로 발생시킨다.
- 또한 유지 보수를 힘들게 한다

6. 애니메이션이 있는 노드는 position을 fixed 또는 absolute로 지정한다.

- 애니메이션이 있는 노드는 많은 리플로우를 발생
- 애니메이션 노드를 분리시켜 해당 노드만 reflow가 발생하도록 하자

7. 애니메이션 퀄리티를 조절하자

- 퀄리티가 좋은 애니메이션은 많은 reflow를 발생한다.
- 따라서 퀄리티와 성능의 타협점을 찾아야함

8. table 태그를 피한다.

- table 태그는 순차적으로 로드되는게 아닌 내부의 모든 값까지 모두 로드되고 나서 테이블 너비를 계산한 후 화면에 그려진다.
- 만약 내부 컨텐츠 값이 변경되어 너비가 다시 계산되야할 때면 테이블의 모든 노드들이 reflow가 발생한다.

9. IE CSS 표현식을 사용하지 않는다.

- CSS 표현식(expression)은 비용이 매우 높기 때문에 사용을 피해야 한다.
- 왜냐하면 reflow가 발생할 때 마다 자바스크립트 식이 다시 게산되기 때문이다.
- 만약 애니메이션이 있다면 reflow가 발생할 때 마다 표현식이 다시 게산되는 것이다.

10. CSS 하위 선택자를 최소화한다.

- reflow 최적화가 아닌 렌더 트리 계산을 최소화하는 방법

11. 숨겨진 노드의 스타일을 변경한다.

- disyplay : none 으로 숨겨진 노드를 변경할 때 reflow를 발생시키지 않음
- display : none 으로 표시된 노드를 display 하기 전 컨텐츠를 변경한 후 display 하면 reflow를 최소화 할 수 있음 (display none 일 때 노드의 내용을 변경하면 reflow가 생기지 않음)

12. 클래스를 혹은 cssText 사용하여 한 번에 스타일을 변경

- 스타일을 각각 추가하면 추가 reflow가 발생할 가능성이 있음

13. DOM 사용을 최소화한다.

- createElement 를 하는게 아닌 createDocumentFragment를 사용하여 Dom 접근을 최소화 할 수 있다 . (여러개를 한번에 DOM에 추가하는 방법)

14. 캐시를 활용한다.

- 브라우저는 레이아웃 변경을 큐에 저장했다가 한번에 실행하여 REFLOW를 최소화 함
- offset, scrolltop 같은 스타일 정보를 제공하기 위해 큐를 비우고 모든 변경사항을 적용함 .
- 이런 낭비를 해결하기 위해 스타일 정보를 변수에 저장하여 scrollTop 등의 값 요청을 최소화 하자.

[참고 사이트 ](https://taeny.dev/graphics/graphics-rendering/)
아래 사이트 = 성능 분석까지 하신 대단한 분 사이트
[참고 사이트 2](https://beomy.github.io/tech/browser/reflow-repaint/)

---

### Browser 렌더링.

- https://www.edwith.org/ 접속시 브라우저에는 어떤 일들이 일어나는가?
  - www.edwith.org 라는 html 파싱
  - css, js, 이미지 정보 추출
  - html 파싱하면서 dom 트리 구축
  - css 파싱
  - 렌더 트리 구축
  - script파일 파싱
  - image 파일 파싱
