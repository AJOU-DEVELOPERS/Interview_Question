> # HTTP 요청

![](https://images.velog.io/images/jinpro/post/58e8c835-027c-4be8-a9f8-784727813667/request.png)

HTTP 요청이란 클라이언트가 서버로 보내는 이진 데이터 패킷.

> # HTTP 프로토콜 특징

- HTTP 프로토콜은 상태가 없는 프로토콜이다. ( 데이터 요청이 서로 독립적이다. => 이전 요청과 다음 요청이 관련이 없다. )
- 일반적으로 TCP/IP 통신 위에서 동작한다.
- HTTP는 비연결성 프로토콜 => 한번의 연결로 한 번의 요청과 응답을 함 => 응답이 끝나면 연결을 끊음 => 연결을 맺고 끊을 때마다 Handshake를 함 => 비연결성 프로토콜에선 overhead 가 생겼다.

> # HTTP Request 종류

- GET
  존재하는 자원에 대한 요청. 오직 데이터를 받기만 한다.
- POST
  새로운 자원을 생성.

- PUT
  리소스의 모든 부분을 수정한다.

- DELETE
  특정 리소스를 삭제한다.
- PATCH
  리소스의 부분 수정
- CONNECT
  목적 리소스로 식별되는 서버로의 터널을 맺는다.

- OPTIONS
  서버 옵션들을 확인하기 위한 요청, CORS에서 사용
- HEAD
  GET 메서드의 요청과 동일한 응답을 요구하지만, 서버 헤더 정보 획득

> # HTTP Response 종류

### 1xx

- 요청을 받

### 2xx

요청 성공을 의미한다.

- 200 : GET 요청에 대한 성공
- 204 : 성공했으나 데이터 없음
- 205 : 성공했으나 새로고침 권고
- 206 : 성공했으나 일부 데이터 반환

### 3xx

리다이렉트 유도

- 301 : 요청한 자원이 새 URL에 존재
- 303 : 요청한 자원이 임시 주소에 존재
- 304 : 요청한 자원이 변경되지 않았으므로 클라이언트 캐싱 자원 사용 권고

### 4xx

클라이언트 에러

- 400 : 잘못된 요청
- 401 : Authorization 헤더 에러 / 권한 없음
- 403 : 서버에서 해당 자원 접근 금지
- 405 : 허용되지 않은 요청
- 409 : 최신 자원이 아님

### 5xx

서버 에러

- 501 : 요청한 동작에 대해 서버 수행 불가능
- 503 : 서버 과부하 또는 유지 보수로 서버 다운

> # Proxy

- 클라이언트와 서버 사이에 위치하여 HTTP 메시지의 중개인 역할
- 웹 서버이자 웹 클라이언트
- 여러 클라이언트가 하나의 Proxy 서버를 공유할 수 있다.

### Proxy vs Gateway

- Proxy는 같은 프로토콜을 사용하는 둘 이상의 애플리케이션 연결
- GateWay는 다른 프로토콜을 사용하는 둘 이상을 연결

### Proxy 사용 이유

- 보안 개선
- 성능 향상
- 비용 절약
- HTTP 트래픽 모니터링 및 수정

> # HTTP Proxy 동작

![](https://images.velog.io/images/jinpro/post/ed7c445c-f733-4140-9996-a649a026d487/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-12-01%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.54.33.png)

- 클라이언트가 HTTP 요청
- Proxy 서버가 수신
- Origin Server로 Proxy 서버가 요청
- Origin Server가 Proxy 서버에 응답
- Proxy 서버가 클라이언트에 응답

![](https://images.velog.io/images/jinpro/post/00affe00-58b9-4fd0-812a-6f0452f1b424/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-12-01%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%203.56.42.png)

- HTTP는 2개 이상의 Proxy 서버를 허용한다.
- 경유 하는 Proxy 서버의 정보를 표시하기 위해 Via 헤더를 삽입한다.

> # HTTP/2 규격과 HTTP/3 규격에 대해 학습

### HTTP/0.9

- 초기 HTTP
- 유일한 GET 메서드
- Header 존재하지않았음

### HTTP/1.0

- 요청에 버전 정보가 붙음
- 응답에 상태 코드 추가
- 모든 요청과 응답에 헤더 추가

### HTTP/1.1

- Connection Keep-Alive => 기존 연결에 대해서 handshake 생략 가능
- 이전 요청에 대한 응답이 전송되기 전에 다음 전송을 보냄
- 응답을 조각조각 청크 단위로 보낸다.
- 캐시 제어

### HTTP/2.0

- 더 빠른 HTTP 통신을 위해 구글이 개발한 SPDY 프로토콜 ( HTTP와 대치하는 프로토콜 X ) 의 개선사항
- 하나의 커넥션으로 동시에 여러 개의 메세지를 주고 받음
- CSS와 Image 파일 수신 순서에 상관 없이 우선순위를 설정하여 브라우저 렌더링 속도 향상
- HTTP/1.1에서는 서버가 HTML을 보내주면 클라이언트가 HTML을 읽으면서 CSS를 서버에 다시 요청했으나 HTTP/2.0부터는 서버가 HTML과 동시에 보내게 되었음.

![](https://images.velog.io/images/jinpro/post/8fb3f289-0c06-4940-a93e-44131e1f3b3b/Comparison-of-HTTP-versions.png)
