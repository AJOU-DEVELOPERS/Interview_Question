> # 쓰레드

![](<https://images.velog.io/images/jinpro/post/fbcce18c-515b-4f98-b15d-81a7ae6df34d/Untitled%20(15).png>)

### 정의

프로세스 내에서 실제로 작업을 수행하는 주체

---

### 특징

- 스레드를 사용하면 사용자에 대한 응답성을 증가시킬 수 있다.
- 프로세스 자원과 메모리를 공유할 수 있다.
  - 힙 메모리
  - 전역 변수
- 쓰레드는 자신만의 스택과 PC 레지스터를 가진다.
- 다중 스레드와 다중 프로세스를 혼합해서 병렬 실행이 가능하다.

#### 독립적인 스택?

쓰레드가 자신만의 독립적인 스택을 가짐으로써 다음과 같은 이점이 발생한다.

먼저 독립적인 스택을 가짐으로써 쓰레드 자신만의 독립적인 함수 호출이 가능하다 -> 독립적인 실행 흐름이 가능하다.

#### 독립적인 PC 레지스터?

쓰레드는 CPU 에 할당되었다가 스케줄러에 의해 선점된다.  
쓰레드의 명령 처리중 선점 되었을 때 되돌아가야 하기 때문에 그 지점을 기억할 필요가 있기 때문에 독립적인 PC 레지스터가 필요하다.

### 프로세스 vs 쓰레드

![what_is_thread_1](https://user-images.githubusercontent.com/66724340/143912843-3df68186-9934-4460-b6b6-886b90ca4393.png)

- 쓰레드는 프로세스보다 생성 , 종료, 전환 시간이 짧다
- 프로세스 메모리, 자원을 공유하므로 커널의 도움없이 상호간 통신이 가능하다.

### 멀티스레드 vs 멀티프로세스

- 멀티 프로세스는 프로세스 간 복잡한 IPC가 필요하며 독립적인 메모리를 가지므로 오버헤드가 발생할 가능성이 있다.
- 멀티 스레드는 멀티 프로세스보다 적은 메모리를 사용하며 Context switching이 빠른 장점이 있지만 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험 있다.
- 반대로 멀티 프로세스는 멀티 스레드보다 안정적이지만 더 많은 cpu 와 메모리 공간을 차지한다는 단점이 있다.
- 멀티 프로세스보다 멀티 스레드 방식이 자원을 효율적으로 사용할 수 도있고 통신에 쓰이는 비용이 적기 때문에 좋아보인다.
- 하지만 전역 변수 사용에 의한 동기화 문제, 디버깅이 어렵다는 문제, 위험하다는 문제가 존재한다.

### 멀티 쓰레드 VS 싱글 쓰레드

Node.js 는 싱글 쓰레드 라고 알려져있다.  
따라서 위의 내용을 읽다보면 Node.js 가 멀티 쓰레드를 사용하는 타 언어 (java) 보다 비효율적이라고 생각도 들 수 있다.

하지만 싱글 쓰레드는 다음과 같은 장점을 가지고 있으며,

- 동기화를 신경쓰지 않아도 된다
- context switch를 요구하지 않는다

멀티 쓰레드는 다음과 같은 단점을 가지고 있다.

- context switch가 많이 일어난다면 느리다
- 동기화 문제가 발생할 수 있다.

또한 node.js 는 시간이 오래 걸리는 I/O 작업은 스레드풀에게 이벤트를 위임하므로 I/O 작업에 자신의 스레드를 할당하지 않는다. (논 블로킹 I/O)

따라서 싱글 스레드로 구성된 node.js 는 일반적인 서버 환경에서는 성능이 오히려 멀티 스레드로 구성된 타 언어보다 좋다.  
또한 타 언어처럼 복잡한 멀티스레드 동기화 작업등의 처리를 안해줘도 된다는 장점도 존재한다.

하지만 단점도 존재하는 데 다음과 같다.

- 싱글 스레드 모델이기 때문에 CPU 계산이 오래걸리면 전체 시스템의 성능이 떨어진다

```javascript
for (let i = 0; i < 1000000000; i++) {
  console.log(i);
}
```

다음과 같은 작업이 있다고 한다면 CPU는 싱글 스레드이기 떄문에 이 작업을 끝마칠 때 동안 다른 작업을 수행하지 못한다.

- 멀티 코어 환경에서 CPU 사용을 최적화 할 수 없고 클러스터 모듈등을 활용하여 여러 노드 프로세스를 사용하는 모델을 만들어야 한다.
- 세션을 공유할 경우 redis와 같은 인프라가 필요하다 (싱글 스레드이기 떄문에 멀티 프로세스를 사용해야한다)
- 가비지 컬렉션이 진행될 동안 cpu 사용률이 급격히 증가한다

---

### 여기서 잠깐 !

![image (1)](https://user-images.githubusercontent.com/66724340/143912712-174281a3-cdb2-4621-a766-87cd6d47c32d.png)

여기까지 읽었다면 의아함을 느꼇을 거다.

싱글 스레드로 구성된 node.js 에서 I/O 작업은 다른 스레드에게 위임한다고?
그렇다면 node.js 는 싱글스레드가 아니지 않나?

맞다 정확하게는 아니다.

사실 자바스크립트 코드가 실행되는 main 스레드는 이벤트 루프가 실행되는 스레드와 같은 스레드이다. (즉 사용자가 작성하는 모든 코드가 콜백이라고 할 수 있다. )
정확하게는 이벤트 루프가 자바스크립트를 실행한다.

![캡처](https://user-images.githubusercontent.com/66724340/143913033-28b16528-d4a7-4f3a-936c-b66a48e13e7a.PNG)
[참고 블로그](https://sjh836.tistory.com/149)

그리고 I/O 작업들은 OS의 비동기 interface 혹은 libuv 라이브러리가 만들어 내는 스레드 풀(기본적으로 4개의 쓰레드가 생성된다)에 전달되어 실행된다.
정확하게는 이벤트 루프가 만나는 거의 모든 비동기 작업은 libuv의 uv_io 에 던져지고 여기서 이벤트의 종류를 파악하며 os에서 처리된다면 OS interface에서 진행되며 커널이 지원하지 않는 API만 libuv 스레드 풀에서 진행된다.

즉 정확하게는 node.js는 싱글스레드로 동작하지 않는다.  
자바스크립트 코드를 돌리는 이벤트 루프가 싱글 스레드 일 뿐이다.
즉 이벤트 루프가 v8 엔진 같은 자바스크립트 엔진을 돌려 자바스크립트를 실행할 뿐이다.

다시 정리하자면 싱글 스레드로 구성된 이벤트 루프가 자바스크립트 엔진을 통해 자바스크립트를 실행하며, 파일 읽기와 같은 OS가 처리할 수 없는 비동기 I/O 작업을 만난다면 libuv 라이브러리의 스레드 풀에게 작업을 위임해 논 블로킹 I/O 을 구현하는 것이다.

정확한건 뒤의 libuv 라이브러리에서 알아보자 .

---

### 노드 환경에서 웹 워커(Web Worker)/워커 스레드(Worker Thread)

#### 웹 워커 & 워커 쓰레드

브라우저는 멀티 스레드로 동작하지만, javascript에서는 싱글 스레드로 웹 브라우저의 모든 동작을 처리 할 수 없고, 시간이 오래걸리는 연산을 처리한다면, 그 시간 동안 다른 작업을 진행할 수 없다.

WebWorker API 를 사용한다면 브라우저 환경에서 멀티 쓰레드를 활용할 수 있다. 따라서 싱글 스레드인 javascript 에서 멀티 코어 cpu 환경을 최대한 활용할 수 있도록 해주는 api이다.

웹 워커란 주 실행 스레드 (자바스크립트 메인 스레드) 와 분리된 별도의 백그라운드 워커 스레드에서 실행할 수 있도록 해주는 객체이다.  
즉, 워커는 이름을 지정한 javascript 파일을 백그라운드 스레드에서 실행할 수 있도록 해주는 객체이다.

만약 자바스크립트에서 어떤 값을 계산하는데에 1초가 걸린다면 그 1초동안 다른 작업을 하지 못한다.  
이때 새로운 쓰레드의 워커를 만들어 워커가 이 계산을 하도록 만든다면 자바스크립트 메인 쓰레드는 다른 작업이 가능하다.  
이런 작업에 쓰이는게 워커이다.

하지만 워커는 HTML 을 구동하는 스크립트(자바스크립트 코드)와 분리된 별도의 파일이므로 메인 쓰레드(HTML의 자바스크립트 코드)에 직접 접근하지 못하며 이벤트를 통해 통신을 해야한다.  
따라서 DOM에 직접 접근은 하지못하며 API 사용에 있어 여러 제약조건이 있다는걸 유의해야한다.

즉 webWorker 는 브라우저 환경에서 멀티 쓰레드를 활용하도록 하게해주는 api 라고 할 수 있다. (nodejs 에서는 libuv의 thread pool을 이용해야한다)

#### webworker 사용에 좋은 예제

• 매우 많은 문자열의 Encoding/Decoding

• 복잡한 수학 계산(소수prime numbers, 암호화 등)

• 매우 큰 배열의 정렬

• 네트워크를 통한 데이터 처리

• local storage 데이터 처리

• 이미지 처리• 비디오나 오디오 데이터 처리

• Background I/O

• 기타 백그라운드에서 오랜 시간 작업해야 하는 경우

• 메인 스레드를 방해하지 않고 지속적으로 수행해야 하는 작업

### libuv 라이브러리

![캡처](https://user-images.githubusercontent.com/66724340/143913033-28b16528-d4a7-4f3a-936c-b66a48e13e7a.PNG)
[참고 블로그](https://sjh836.tistory.com/149)

nodejs = v8 엔진 + libuv 라이브러리로 구성되어 있다.
libuv 라이브러리는 node js에서 비동기 I/O 를 지원하기 위해 구현된 라이브러리이다.
내부적으로는 C/C++를 이용해 구현되어 있다.

libuv 내부에는 이벤트 루프와 uv.io , 쓰레드 풀 등이 존재한다.  
이 중 uv.io 가 node.js의 논 블로킹된 비동기 함수들을 처리한다.
uv.io 에서 os 가 처리할 수 있는 api인지 아닌지 판단하여 os에 작업을 넘기거나 쓰레드 풀에서 비동기 작업을 처리한다.

uv_io에서 I/O 또는 네트워크 작업등의 비동기 작업이 끝나면 그 작업결과를 담은 콜백함수가 콜백 큐에 등록된다.

이 때 콜백 큐는 한개의 큐가 아니라 이벤트의 종류에 따라 여러개의 큐가 존재한다.  
그리고 이벤트 루프의 콜 스택이 비었을 때 이 콜백 큐에서 FIFO 방식으로 하나하나 꺼내진다.

## Thread Pool

- 스레드가 생성될 때 운영체제가 메모리 공간을 확보하여 스레드에 할당해준다.
- 스레드는 동일한 메모리 영역에서 생성되고 관리되지만, 생성 및 수거에 드는 비용을 무시할 수 없다.

#### 해결방안

![](https://images.velog.io/images/jinpro/post/f5068340-a8c6-4172-8c43-4d19a442e319/231B374B595F67F43A.png)

Thread를 미리 만들어 놓는다. => Thread Pool

### 동작 원리

작업큐에 들어온 Task를 Thread에 할당한다.

### 장점

- 프로그램 성능 저하 방지
- 다수의 사용자 요청 처리 가능

### 단점

- Thread 사용량에 비해 많은 Thread를 생성한다면 메모리 낭비 발생
- Thread 들 사이 유동적인 일처리가 불가능 ( A Thread가 일이 남아있으면 B Thread가 나누어서 일처리를 해주지 않음 ) => ForkJoin방식으로 해결
